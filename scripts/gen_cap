#!/usr/bin/env python3
# See LICENSE file for copyright and license details.
import yaml
from yaml.loader import SafeLoader
import argparse
import re

def binpack(bins, fields):
    if len(fields) == 0:
        return [[],[]]
    f, s = fields[0]
    for i, b in enumerate(bins):
        if s > b:
            continue
        new_bins = bins.copy()
        new_bins[i] -= s
        packing = binpack(new_bins, fields[1:])
        if packing:
            packing[i].append((f,s))
            return packing
    return None

def get_offset(b, f):
    offset = 0
    for (ff, s) in b:
        if ff == f:
            return offset
        offset += s * 8

def get_bin(bins, f):
    for i, b in enumerate(bins):
        for (ff,s) in b:
            if ff == f:
                return i, b

def make_assert(s):
    return f"kassert({s});"

def make_getter(cap_name, name, size, bins):
    output = list()
    if name == 'padd':
        return
    output.append(f"static inline uint64_t cap_{cap_name}_get_{name}(cap_t cap) {{")
    make_assert(f"cap_is_type(cap, CAP_TYPE_{cap_name.upper()})")
    i, b = get_bin(bins, name)
    offset = get_offset(b, name)
    if i == 0:
        offset += 8
    if offset:
        output.append(f"return (cap.word{i} >> {offset}) & 0x{'ff'*size}ull;")
    else:
        output.append(f"return cap.word{i} & 0x{'ff'*size}ull;")
    output.append('}')
    return "\n".join(output)

def make_setter(cap_name, name, size, bins):
    output = list()
    if name == 'padd':
        return
    output.append(f'static inline cap_t cap_{cap_name}_set_{name}(cap_t cap, uint64_t {name}) {{')
    make_assert(f"cap_is_type(cap, CAP_TYPE_{cap_name.upper()})")
    make_assert(f"({name} & 0x{'ff'*size}ull) == {name}")
    i, b = get_bin(bins, name)
    offset = get_offset(b, name)
    if i == 0:
        offset += 8
    mask = f"0x{'ff'*size + '00'*(offset//8)}ull"
    if offset:
        output.append(f"cap.word{i} = (cap.word{i} & ~{mask}) | {name} << {offset};")
    else:
        output.append(f"cap.word{i} = (cap.word{i} & ~{mask}) | {name};")
    output.append("return cap;")
    output.append("}")
    return "\n".join(output)

def make_constructor(cap_name, fields, asserts, bins):
    output = list()
    parameters = [f"uint64_t {name}" for (name, size) in fields if name != 'padd']
    output.append(f"static inline cap_t cap_mk_{cap_name}({', '.join(parameters)}) {{")
    for (name, size) in fields:
        if name != 'padd':
            make_assert(f"({name} & 0x{'ff'*size}ull) == {name}")
    for a in asserts:
        make_assert(a)
    output.append("cap_t c;")
    output.append(f"c.word0 = (uint64_t)CAP_TYPE_{cap_name.upper()};")
    output.append(f"c.word1 = 0;")
    for (i,b) in enumerate(bins):
        for (f, s) in b:
            if f == 'padd':
                continue
            offset = get_offset(b, f)
            if i == 0:
                offset += 8
            if offset:
                output.append(f"c.word{i} |= {f} << {offset};")
            else:
                output.append(f"c.word{i} |= {f};")
    output.append("return c;")
    output.append("}")
    return "\n".join(output)

def make_revokable(caps):
    output = list()
    output.append("static inline int cap_is_revokable(cap_t cap) {")
    p = [f"cap_is_type(cap, CAP_TYPE_{cap['name'].upper()})" for cap in caps if cap['revokable']]
    output.append(f"return {'&&'.join(p)};")
    output.append("}")
    return "\n".join(output)

def make_cap_functions(data):
    output = list()
    if 'fields' not in data:
        return ""
    cap_name = data['name']
    fields = [tuple(f.split()) for f in data['fields']]
    fields = [(n, int(s)) for n, s in fields]
    bins = binpack([7,8], fields)
    asserts = data['asserts'] if 'asserts' in data else []
    output.append(make_constructor(cap_name, fields, asserts, bins))
    for (f, s) in fields:
        output.append(make_getter(cap_name, f, s, bins))
        output.append(make_setter(cap_name, f, s, bins))
    return "\n".join(output)

def make_translator(case):
    pairs = []
    for rel in case['conditions']:
        pairs += re.findall(r'\w:[a-z]+', rel)
    pairs = list(set(pairs))
    dic = dict()
    for pair in pairs:
        v,f = pair.split(':')
        if v == 'p':
            dic[pair] = f"cap_{case['parent']}_get_{f}(p)"
        if v == 'c':
            dic[pair] = f"cap_{case['child']}_get_{f}(c)"
    rels = []
    for rel in case['conditions']:
        for key, val in dic.items():
            rel = rel.replace(key, val)
        rels.append("(" + rel + ")")
    case['conditions'] = rels

def make_pred_case(case):
    output = list()
    parent_type = f"CAP_TYPE_{case['parent'].upper()}"
    child_type = f"CAP_TYPE_{case['child'].upper()}"
    make_translator(case)
    output.append(f"if (cap_is_type(p,{parent_type}) && cap_is_type(c, {child_type}))")
    output.append(f"return {'&&'.join(case['conditions'])};")
    return "\n".join(output)

def make_pred(p):
    output = list()
    name=p['name']
    output.append(f"static inline int cap_{name}(cap_t p, cap_t c) {{")
    for case in p['cases']:
        make_pred_case(case)
    output.append("return 0;")
    output.append("}")
    return "\n".join(output)


# Open the file and load the file

def main(data):

    caps = data['caps']
    enums = ", ".join([f"CAP_TYPE_{d['name'].upper()}"  for d in caps])
    
    hdr = f"""\
#pragma once
#include "kassert.h"
#include <stdint.h>

#define NULL_CAP ((cap_t){{0,0}})

typedef enum cap_type cap_type_t;
typedef struct cap cap_t;

enum cap_type {{
{enums}, NUM_OF_CAP_TYPES
}};

struct cap {{
unsigned long long word0, word1;
}};


static inline uint64_t pmp_napot_begin(uint64_t addr) {{
    return addr & (addr + 1);
}}

static inline uint64_t pmp_napot_end(uint64_t addr) {{
    return addr | (addr + 1);
}}

static inline cap_type_t cap_get_type(cap_t cap) {{
return 0xffull & cap.word0;
}}

static inline int cap_is_type(cap_t cap, cap_type_t t) {{
    return cap_get_type(cap) == t;
}}
"""

    output = list()
    output.append(hdr)
    
    for i in caps:
        output.append(make_cap_functions(i))
    
    output.append(make_revokable(caps))
    
    for p in data['predicates']:
        output.append(make_pred(p))

    return "\n".join(output)

if __name__ == "__main__":
    parser = argparse.ArgumentParser(
            prog = "gen_cap",
            description = "Generate capability header file from yaml description")
    parser.add_argument("yaml")
    parser.add_argument("output")
    args = parser.parse_args()
    with open(args.yaml, 'r') as f:
        data = yaml.safe_load(f)
    output = main(data)
    if args.output == "-":
        print(output)
    else:
        with open(args.output, "w") as f:
            print(output, file=f)
    
